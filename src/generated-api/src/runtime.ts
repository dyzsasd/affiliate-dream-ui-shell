
/* tslint:disable */
/* eslint-disable */
/**
 * Affiliate Backend API
 * API Server for Affiliate Backend Application
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


/**
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 * @export
 * @enum {string}
 */
export enum FetchError {
    UNKNOWN = 'UNKNOWN',
    HTTP_ERROR = 'HTTP_ERROR',
    PARSING = 'PARSING',
    REQUEST_FAILED = 'REQUEST_FAILED',
}

/**
 * @export
 */
export type HTTPMethod =
    | 'GET'
    | 'POST'
    | 'PUT'
    | 'PATCH'
    | 'DELETE'
    | 'HEAD'
    | 'OPTIONS';

/**
 * @export
 */
export type HTTPHeaders = { [key: string]: string };

/**
 * @export
 */
export type HTTPQuery = { [key: string]: any };

/**
 * @export
 */
export interface ConfigurationParameters {
    apiKey?: string | ((name: string) => string);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
    credentials?: RequestCredentials; // can be 'same-origin', 'include', 'omit', etc.
    headers?: HTTPHeaders; //header params we want to use on every request
    middleware?: Middleware[];
    queryParamsStringify?: (params: HTTPQuery) => string;
    mode?: 'cors' | 'no-cors' | 'same-origin'; // CORS setting for the Fetch API
    securityWorker?: (securityData: SecurityDataType | null) => Promise<RequestInit | void> | RequestInit | void;
}

/**
 * @export
 */
export class Configuration {
    /**
     * parameter for apiKey security
     * @param name name of the api key parameter in the request
     * @param apiKey api key string
     */
    apiKey?: string | ((name: string) => string);
    /**
     * parameter for basic security
     * @param username username
     * @param password password
     */
    username?: string;
    password?: string;
    /**
     * parameter for oauth2 security
     * @param accessToken access token string
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>);
    /**
     * override base path
     *
     * @param basePath base path
     */
    basePath?: string;

    /**
     * base options for fetch calls
     *
     * @param baseOptions base options
     */
    baseOptions?: any;

    /**
     * The FormData constructor that will be used to create request bodies of the 'multipart/form-data' media type.
     *
     * @param formDataCtor The FormData constructor.
     */
    formDataCtor?: new () => any;

    /**
     * CORS credentials setting
     */
    credentials?: RequestCredentials;

    /**
     * CORS mode
     */
    mode?: 'cors' | 'no-cors' | 'same-origin';

    /**
     * Default headers for all requests
     */
    headers?: HTTPHeaders;

    /**
     * Middleware for request/response processing
     */
    middleware?: Middleware[];

    constructor(configuration: ConfigurationParameters = {}) {
        this.apiKey = configuration.apiKey;
        this.username = configuration.username;
        this.password = configuration.password;
        this.accessToken = configuration.accessToken;
        this.basePath = configuration.basePath;
        this.baseOptions = configuration.baseOptions;
        this.formDataCtor = configuration.formDataCtor;
        this.credentials = configuration.credentials;
        this.mode = configuration.mode;
        this.headers = configuration.headers;
        this.middleware = configuration.middleware;
    }

    /**
     * Check if the given MIME type is JSON
     * @param mime - MIME type
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[^;/ \t]*$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/**
 * @export
 */
export interface RequestOpts {
    path: string;
    method: string;
    query?: string;
    body?: any;
    headers: HTTPHeaders;
    base?: string;
}

/**
 * @export
 */
export type SecurityDataType = { [key: string]: SecurityScheme };

/**
 * @export
 */
export type SecurityScheme = {
    type: string;
    apiKey?: string;
    bearerFormat?: string;
    scheme?: string;
};

/**
 * @export
 */
export type Middleware = {
    pre?: (context: RequestContext) => Promise<void> | void;
    post?: (context: ResponseContext) => Promise<void> | void;
}

/**
 * @export
 */
export interface RequestContext {
    httpMethod: HTTPMethod;
    url: string;
    headers: HTTPHeaders;
    body: any;
    credentials?: RequestCredentials;
}

/**
 * @export
 */
export interface ResponseContext {
    httpMethod: HTTPMethod;
    url: string;
    headers: HTTPHeaders;
    body: any;
    statusCode: number;
    credentials?: RequestCredentials;
}

/**
 * @export
 * @function
 */
export type InitOverrideFunction = (requestContext: { init: RequestInit, context: RequestOpts }) => Promise<RequestInit>

/**
 *
 * @export
 * @namespace
 */
export const RequiredErrorParam = {
    /**
     *
     * @param paramName The name of the missing parameter.
     * @param context The path of the API endpoint that is missing the parameter.
     * @returns An error describing that the parameter is missing.
     */
    construct: (paramName: string, context: string) => {
        return new Error(`Required parameter ${paramName} was null or undefined when calling ${context}.`);
    }
}

/**
 * @export
 * @class RequiredError extends Error
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * @import fetch from 'node-fetch';
 *
 * @export
 */
const globalFetch = globalThis.fetch || (
    (typeof window !== 'undefined') ? window.fetch : undefined
);

/**
 * @export
 */
export const DefaultFetch = globalFetch ? globalFetch.bind(globalThis) : (() => {
    throw new Error("fetch is not available in current environment. Please add a fetch implementation (e.g. node-fetch, isomorphic-fetch) to your environment.");
});

/**
 * @export
 */
export const BASE_PATH = "/api/v1".replace(/\/+$/, "");

/**
 * API Response classes for handling different response types
 */
export class ApiResponse<T> {
    raw: Response;
    constructor(raw: Response) {
        this.raw = raw;
    }
}

export class VoidApiResponse extends ApiResponse<void> {
    constructor(raw: Response) {
        super(raw);
    }
    
    async value(): Promise<void> {
        return undefined;
    }
}

export class JSONApiResponse<T> extends ApiResponse<T> {
    constructor(raw: Response) {
        super(raw);
    }
    
    async value(): Promise<T> {
        return await this.raw.json();
    }
}

export class TextApiResponse extends ApiResponse<string> {
    constructor(raw: Response) {
        super(raw);
    }
    
    async value(): Promise<string> {
        return await this.raw.text();
    }
}

export class BlobApiResponse extends ApiResponse<Blob> {
    constructor(raw: Response) {
        super(raw);
    }
    
    async value(): Promise<Blob> {
        return await this.raw.blob();
    }
}

/**
 * @export
 * Base API class
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration) {
        this.configuration = configuration;
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { base, path, query, body, method, headers } = context;
        
        // Ensure path has api/v1 prefix
        const apiPath = path.startsWith('/api/v1') ? path : path.startsWith('/') ? `/api/v1${path}` : `/api/v1/${path}`;
        
        const baseUrl = (this.configuration?.basePath || BASE_PATH).replace(/\/+$/, "");
        const endpoint = `${baseUrl}${apiPath}${query ? `?${query}` : ''}`;
        
        // Log the full URL for debugging
        console.log(`Making ${method} request to: ${endpoint}`);
        
        const auth = this.configuration?.apiKey 
            ? await this.configuration?.apiKey("Authorization") 
            : undefined;
            
        if (auth) {
            console.log(`Using auth: ${auth.substring(0, 15)}...`);
        } else {
            console.log("No auth token provided");
        }
        
        // Always include proper CORS headers and credentials
        const corsHeaders: HeadersInit = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        
        if (auth) {
            corsHeaders['Authorization'] = auth;
        }
        
        const init: RequestInit = {
            method,
            headers: { ...corsHeaders, ...headers },
            body,
            mode: 'cors',
            credentials: 'include',
        };
        
        // Apply any overrides
        const overridden = typeof initOverrides === 'function' 
            ? { ...init, ...await initOverrides({ init, context }) } 
            : { ...init, ...initOverrides };
        
        // Additional debug logging
        console.log(`Final request config for ${method} ${endpoint}:`, {
            method: overridden.method,
            mode: overridden.mode,
            credentials: overridden.credentials,
            headers: overridden.headers,
            bodyLength: overridden.body ? 'present' : 'none'
        });
        
        try {
            const response = await fetch(endpoint, overridden);
            console.log(`Response from ${method} ${endpoint}:`, {
                status: response.status,
                statusText: response.statusText,
                type: response.type,
                ok: response.ok
            });
            return response;
        } catch (error) {
            console.error(`Error in ${method} ${endpoint}:`, error);
            throw error;
        }
    }
}

/**
 * @throws {FetchError}
 * @export
 */
export const assertParamExists = function (functionName: string, paramName: string, paramValue: any) {
    if (paramValue === null || paramValue === undefined) {
        throw new FetchError(`Missing required parameter ${paramName} in ${functionName}.`, FetchError.PARSING);
    }
}

/**
 * @export
 */
export const setSearchParams = (url: URL, ...params: any[]) => {
    const flattenedParams = params.reduce(
        (acc, param) => acc.concat(param),
        []
    );
    for (const param of flattenedParams) {
        if (param instanceof URLSearchParams) {
            for (const key of param.keys()) {
                url.searchParams.append(key, param.get(key) as string);
            }
        } else if (typeof param === 'object' && param !== null) {
            for (const key of Object.keys(param)) {
                const value = param[key];
                if (value !== undefined) {
                    url.searchParams.append(key, value);
                }
            }
        }
    }
}

/**
 * @export
 */
export const toPathString = function (url: URL) {
    return url.pathname + url.search + url.hash
}

/**
 * @export
 */
export const encodeURI = function (str: string) {
    return encodeURIComponent(str);
}
